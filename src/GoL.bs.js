// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Random = require("bs-platform/lib/js/random.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var LogUpdate = require("log-update");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

Random.init(Date.now() | 0);

function mapCondition(cond) {
  switch (cond) {
    case 0 : 
        return "◽";
    case 1 : 
        return "◾";
    case 2 : 
        return "";
    
  }
}

function mapRow(row) {
  return $$Array.map(mapCondition, row).join(" ");
}

function printBoard(board) {
  LogUpdate($$Array.map(mapRow, board).join("\n"));
  return /* () */0;
}

var Output = /* module */[
  /* mapCondition */mapCondition,
  /* mapRow */mapRow,
  /* printBoard */printBoard
];

function createCondition() {
  var match = Random.$$int(10) < 4;
  if (match) {
    return /* Alive */0;
  } else {
    return /* Dead */1;
  }
}

var initialBoard = $$Array.make_matrix(30, 80, 0);

function seed(board) {
  return $$Array.map((function (row) {
                return $$Array.map((function () {
                              return createCondition(/* () */0);
                            }), row);
              }), board);
}

var board = /* record */[/* contents */seed(initialBoard)];

var neighbourOffsets = /* :: */[
  /* tuple */[
    -1,
    -1
  ],
  /* :: */[
    /* tuple */[
      -1,
      0
    ],
    /* :: */[
      /* tuple */[
        -1,
        1
      ],
      /* :: */[
        /* tuple */[
          0,
          -1
        ],
        /* :: */[
          /* tuple */[
            0,
            1
          ],
          /* :: */[
            /* tuple */[
              1,
              -1
            ],
            /* :: */[
              /* tuple */[
                1,
                0
              ],
              /* :: */[
                /* tuple */[
                  1,
                  1
                ],
                /* [] */0
              ]
            ]
          ]
        ]
      ]
    ]
  ]
];

function getAliveNeighbours(board, coordinates) {
  var y = coordinates[1];
  var x = coordinates[0];
  var __x = List.map((function (param) {
          try {
            return Caml_array.caml_array_get(Caml_array.caml_array_get(board[0], y + param[0] | 0), x + param[1] | 0);
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
              return /* OutOfBounds */2;
            } else {
              throw exn;
            }
          }
        }), neighbourOffsets);
  return List.fold_left((function (acc, item) {
                if (item !== 0) {
                  return acc;
                } else {
                  return acc + 1 | 0;
                }
              }), 0, __x);
}

function isDeadOrAlive(condition, numAliveNeighbours) {
  switch (condition) {
    case 0 : 
        if (numAliveNeighbours === 3 || numAliveNeighbours === 2) {
          return /* Alive */0;
        } else {
          return /* Dead */1;
        }
    case 1 : 
        if (numAliveNeighbours !== 3) {
          return /* Dead */1;
        } else {
          return /* Alive */0;
        }
    case 2 : 
        return /* Dead */1;
    
  }
}

function tick(board) {
  return $$Array.mapi((function (rowIndex, row) {
                return $$Array.mapi((function (colIndex, cell) {
                              return isDeadOrAlive(cell, getAliveNeighbours(board, /* tuple */[
                                              colIndex,
                                              rowIndex
                                            ]));
                            }), row);
              }), board[0]);
}

printBoard(board[0]);

setInterval((function () {
        board[0] = tick(board);
        return printBoard(board[0]);
      }), 250);

exports.Output = Output;
exports.createCondition = createCondition;
exports.initialBoard = initialBoard;
exports.seed = seed;
exports.board = board;
exports.neighbourOffsets = neighbourOffsets;
exports.getAliveNeighbours = getAliveNeighbours;
exports.isDeadOrAlive = isDeadOrAlive;
exports.tick = tick;
/*  Not a pure module */
